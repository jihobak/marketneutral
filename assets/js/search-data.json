{
  
    
        "post0": {
            "title": "Kelly Criterion",
            "content": "By: Jiho Bak | Email: jihobak0@gmail.com | . Introduction . After reading this notebook, you can answer below questions . There is a coin tossing gamble. The coin is fair. If the head comes out, you can get three times as much money as you bet. But, if the tail comes out, you lose all your bet. What is the optimal bet size for this game? | . There is another game. It is a dice gamble. The dice is fair and there are numbers from one to six on each side. If you throw the dice and the number six comes out, this game will return nine times the money you bet. But other numbers come out, you lose all you bet. Between the coin game described above and the dice game, which game is advantageous, and how much money should you bet on each game? | . How can we use the Kelly formula when investing in a single stock or running a portfolio in the stock market? | . In the real world, what should you take care of when applying the Kelly Criterion? | . Why do we need to care about bet size? . Let&#39;s say there is a coin tossing gamble and the coin is fair. If the head comes out, you can get two times as much money as you bet. But, if the tail comes out, you lose all your bet. If there are ten thousand of people whose initial capital is $100 and they have to bet all of their bankroll at every game. What will be the result? . from collections import Counter import numpy as np import pandas as pd from matplotlib import pyplot as plt from mlfinlab.bet_sizing import kelly_betting, kelly_investing, kelly_allocation %matplotlib inline . def toss_coin(prob_head, bankroll, odds, fraction): &quot;&quot;&quot; Calculates the bankroll after the toss. &quot;&quot;&quot; coin_toss = np.random.binomial(1, prob_head) if coin_toss == 1: return bankroll*((1+odds*fraction)**coin_toss) else: return bankroll*(1-fraction) . def coin_simulation(max_trials, prob_head, bankroll, bankrupt_line, odds, fraction): &quot;&quot;&quot; Simulates multiple coin tossing and return the history or the bankroll and the number of trials until getting bankrupt. &quot;&quot;&quot; initial_bankroll = bankroll bankroll_history = np.zeros(max_trials+1) bankroll_history[0] = initial_bankroll for toss in range(max_trials): bankroll = toss_coin(prob_head, bankroll, odds, fraction) if bankroll &lt;= bankrupt_line: return (bankroll_history/initial_bankroll-1), toss+1 else: bankroll_history[toss+1]=bankroll return (bankroll_history/initial_bankroll-1), max_trials+1 . num_sim = 10000 # the number of people who participate in the gamble. max_trials = 10 # maximum number of games a person can participate in prob_head = 0.5 # the probability that the head of a coin will come out. bankroll = 100 # initial bankroll bankrupt_line = 1 # If their bankroll is less than $1, they are considered bankrupt. odds = 1 fraction = 1 simulations = [coin_simulation(max_trials, prob_head, bankroll, bankrupt_line, odds, fraction) for i in range(num_sim)] return_sim = [ round(history[-1],2) for history, survival in simulations] sur_sim = [ survival for history, survival in simulations] bankrupt_counter = Counter(sur_sim) ret_counter = Counter(return_sim) fig, ax = plt.subplots(1, 2, figsize=(20, 10)) ax[0].hist(sur_sim, color=&#39;r&#39;,bins=range(1, max_trials+2)) ax[0].set_title(&quot;Distribution of the number of trial until getting bankrupt&quot;) ax[0].set_xlabel(&quot;the number of trial&quot;) ax[0].set_ylabel(&quot;the number of the gamblers&quot;) ax[1].hist(return_sim) ax[1].set_title(f&quot;Distribution of the returns of gamblers after {max_trials} trials&quot;) ax[1].set_xlabel(&quot;returns of gamblers&quot;) ax[1].set_ylabel(&quot;the number of the gamblers&quot;) plt.show() print(f&quot;bankrupt_counter:{bankrupt_counter}&quot;) print(f&quot;return_counter:{ret_counter}&quot;) . bankrupt_counter:Counter({1: 5026, 2: 2534, 3: 1216, 4: 604, 5: 318, 6: 143, 7: 90, 8: 35, 9: 21, 11: 11, 10: 2}) return_counter:Counter({-1.0: 9989, 1023.0: 11}) . As you can see, most of the people go bankrupt after ten bets. Intuitively, you can see that it is foolish to bet all your bankroll on a single bet. . However, What is the expected return of a single bet in this game? It&#39;s $0.5. it might be reasonable to bet $0.5 based on the expectation. But, you know it is not. This is the reason why we should cosider the growth rate rather than absolute return because we don&#39;t have infinite amount of money in the real world. . $$ E[r] = frac{1}{2}*2- frac{1}{2}*1=0.5$$ . What happens if you bet on a portion of your fortune instead of all in? Let&#39;s check when people wager 20% or 80% of their fortune on each bet. . num_sim = 10000 # the number of people who participate in the gamble. max_trials = 10 # maximum number of games a person can participate in prob_head = 0.5 # the probability that the head of a coin will come out. bankroll = 100 # initial bankroll bankrupt_line = 1 # If their bankroll is less than $1, they are considered bankrupt. odds = 1 fraction = [0.2, 0.8] figs, axes = plt.subplots(len(fraction), 2, figsize=(20, 10)) for option, ax in enumerate(axes): # Simulation simulations = [coin_simulation(max_trials, prob_head, bankroll, bankrupt_line, odds, fraction[option]) for i in range(num_sim)] return_sim = [ round(history[-1],2) for history, survival in simulations] sur_sim = [ survival for history, survival in simulations] bankrupt_counter = Counter(sur_sim) ret_counter = Counter(return_sim) # Plot ax[0].hist(sur_sim, color=&#39;r&#39;,bins=range(1,max_trials+2)) ax[0].set_title(f&quot;Distribution of the number of trial until getting bankrupt(fraction:{fraction[option]})&quot;) ax[0].set_xlabel(&quot;the number of trial&quot;) ax[0].set_ylabel(&quot;the number of the gamblers&quot;) ax[1].hist(return_sim, bins=50) ax[1].set_title(f&quot;Distribution of the returns of gamblers after {max_trials} trials(fraction:{fraction[option]})&quot;) ax[1].set_xlabel(&quot;returns of gamblers&quot;) ax[1].set_ylabel(&quot;the number of the gamblers&quot;) print(f&quot;bankrupt_counter(fraction:{fraction[option]}):{bankrupt_counter}&quot;) print(f&quot;return_counter(fraction:{fraction[option]}):{ret_counter}&quot;) print() plt.show() . bankrupt_counter(fraction:0.2):Counter({11: 10000}) return_counter(fraction:0.2):Counter({-0.18: 2513, 0.22: 2034, -0.46: 2022, 0.83: 1196, -0.64: 1132, 1.75: 457, -0.76: 422, -0.84: 104, 3.13: 92, 5.19: 19, -0.89: 9}) bankrupt_counter(fraction:0.8):Counter({11: 3401, 7: 1496, 6: 1382, 3: 1218, 5: 965, 10: 876, 9: 662}) return_counter(fraction:0.8):Counter({-1.0: 6599, -0.95: 1676, -0.51: 1193, 3.41: 424, 38.67: 105, 356.05: 3}) . Increasing betting size increases the probability of bankruptcy while lowering the betting size makes the final return smaller. We need to find the optimal betting size to maximize returns while reducing the probability of bankruptcy in multiple gambling games. Here comes the Kelly Criterion. . What is Kelly Criterion? . The Kelly Criterion was first introduced in the paper by John Larry Kelly(1923~1965)[1] who was a research scientist at Bell Labs. From the Kelly criterion, we can answer the question like, &quot;How much of my fortune should I bet on in this bet to maximize the long-term growth rate of my wealth?&quot;. . Kelly criterion . $$ X_{n} = X_{0}(1+bf)^{w}(1-af)^{l} $$ . begin{cases} X_{n} : text{capital after n bets} X_{0} : text{initial capital} f : text{fraction of the bankroll to be wagered on each bet} w : text{the number of win} l : text{the number of lose} b : text{profit per unit bet} a : text{loss per unit bet} end{cases} For example, there is a coin tossing gamble. The coin is fair. If the head comes out, you can get three times as much money as you bet. But, if the tail comes out, you lose all your bet. Your initial capital is $100 and you won 7 times in 10 trials. . begin{cases} X_{n} : text{capital after n bets} X_{0} : text{ $100} w : 7 l : 3 b : 2 a : 1 end{cases} what the Kelly criterion target is that maximizing the expected value of the exponential growth rate. $f$ is the fraction of the capital to be bet. . begin{equation} begin{split} g(f) &amp;= E[log( frac{X_{n}}{X_{0}})] &amp;= plog(1+bf)+qlog(1-af) end{split} end{equation} begin{cases} p : text{probability of win} q : text{probability of lose} end{cases} The Kelly criterion says optimal fraction, . $$f^{*} = frac{bp-aq}{ab}= frac{p}{a}- frac{q}{b}$$ . kelly betting . In the case of the above example, we should wager 25% of our bankroll based on the kelly criterion . $$ f^{*} = frac{0.5}{1}- frac{0.5}{2} = 0.25 $$ . optimal_fraction, expected_grow_rate = kelly_betting(win_probability=0.5, profit_unit=2, loss_unit=1) print(f&quot;optimal fraction : {optimal_fraction}&quot;) print(f&quot;expected_growth_rate: {expected_grow_rate:.3f}&quot;) . optimal fraction : 0.25 expected_growth_rate: 0.059 . There is another game. It is a dice gamble. The dice is fair and there are numbers from one to six on each side. If you throw the dice and the number six comes out, this game will return nine times the money you bet. But other numbers come out, you lose all you bet. Between the coin game described above and the dice game, which game is advantageous, and how much money should you bet on each game? . First, check the expectation of return. Based on the expected return, the dice gamble looks good. ($ 0.666... &gt; 0.5 $) . $$ E[r_{coin}] = frac{1}{2}*2- frac{1}{2}*1=0.5$$ $$ $$ $$ E[r_{dice}] = frac{1}{6}*9- frac{5}{6}*1=0.66666...$$ . Dice gamble . optimal_fraction, expected_grow_rate = kelly_betting(win_probability=1/6, profit_unit=8, loss_unit=1) print(f&quot;optimal fraction : {optimal_fraction:.3f}&quot;) print(f&quot;expected_growth_rate: {expected_grow_rate:.3f}&quot;) . optimal fraction : 0.062 expected_growth_rate: 0.014 . From the Kelly criterion, It&#39;s better to play coin gamble because we can expect higher growth rates in the long run. That&#39;s because it also takes into account the probability of losing all the money. Some people explain this choice from the behavioral bias. but it&#39;s a rational choice [4][5]. . What if we don&#39;t follow the kelly betting? . def grow_rate(odds, win_prob, fraction): &quot;&quot;&quot; Calculates expected growth rate &quot;&quot;&quot; p = win_prob q = 1-p return p*np.log(1+fraction*odds) + q*np.log(1-fraction) x = np.linspace(0, 0.6, 1000) y = [ grow_rate(2, 0.5, f) for f in x] plt.figure(figsize=(10,5)) plt.plot(x, y) plt.title(f&quot;Expected value of the exponential growth rate of wealth by $f$&quot;) plt.xlabel(&quot;$f$&quot;) plt.ylabel(&quot;$g(f)$&quot;) plt.axhline(y=0, color=&#39;r&#39;, linewidth=1) plt.axvline(x=0.25, color=&#39;g&#39;, linewidth=1.5) plt.axvline(x=0.5, color=&#39;r&#39;, linestyle=&#39;--&#39;, linewidth=1) plt.show() . If you make a bet larger than Kelly bet size, the expected growth rate will start to shrink and at some point the growth rate will be negative. . In the real world, we usually don&#39;t know the true probability of a win. So, we always estimate the probability. As a result, it is likely that we bet bigger than the actual kelly bet size. Sometimes, it leads to a negative expected growth rate. . For example, in the above example of a coin game, if you guessed the probability of a coin coming out front was $2/3$, the expected growth rate will be zero. . true_probability = 0.5 estimated_probability = 2/3 optimal_fraction, _ = kelly_betting(win_probability=estimated_probability, profit_unit=2, loss_unit=1) print(f&quot;optimal fraction : {optimal_fraction:.3f}&quot;) print(f&quot;expected_growth_rate: {grow_rate(2, true_probability, optimal_fraction):.3f}&quot;) . optimal fraction : 0.500 expected_growth_rate: 0.000 . Therefore, when using the kelly criterion, you should always keep in mind that you may do over betting. . Kelly Investing . from mlfinlab.bet_sizing import kelly_investing . We can also appy the Kelly criterion to the stock market, but it is different from betting enviorment. Since it is not a binary event and there are infinte number of outcomes of investing, we have to use continuous probability distribution not a discrete one. . If we assume our return of equity is follow $N( mu, sigma^{2})$, then optimal leverage $f^{*}$ will generate the highest compounded growth rate of equity [2].($r$ is risk free) . $$ f^{*} = frac{ mu-r}{ sigma^{2}} $$ . The long-term growth rate $g(f^{*})$ is below by [1]. . $$ g(f^{*}) = frac{(m-r)^{2}}{2s^2} + r $$ . When you apply Kelly Criterion in the real world, you should keep in mind that the Kelly Criterion requires a continuous rebalancing of capital to keep the leverage ration constant [2][3]. But, as you know, it&#39;s impossible to do it in the real world. At least, you should at least try to keep up with it such as rebalancing your portfolio once a day. . For example, You have $100 at first. The optimal leverage from the Kelly Criterion is 2($f=2$) and the daily return of the asset is 10%. Then, your target portfolio value should be $240, not $200 after a trade because you earn $20 and your account value is $120. It means that you have to buy another $20 worth of an asset to keep the leverage ratio($f=2$). . def kelly_trader(portfolio_value, account_value, target_leverage, daily_return): &quot;&quot;&quot; Calculates account value, portfolio value, addition trade value after a trade(return is daily_return(%)) &quot;&quot;&quot; # profit after the trade when return is &#39;daily_return(%)&#39; profit = portfolio_value*daily_return # account value after the trade new_account_value = account_value + profit # portfolio value that you should target after the trade new_target_portfolio_value = target_leverage * new_account_value # the amount of dollar that you should trade to resize portfolio gap = new_target_portfolio_value - (portfolio_value+profit) return new_account_value, new_target_portfolio_value, gap . account_value = 100 kelly_leverage = 2 portfolio_value = 2*account_value # You borrowed $100. daily_return = 0.1 new_account, new_portfolio_value, additional_trade = kelly_trader(portfolio_value, account_value, kelly_leverage, daily_return) print(f&quot;Now, Your account value is ${new_account}&quot;) print(f&quot;You have to buy ${additional_trade} to keep the leverage({kelly_leverage}) ratio.&quot;) print(f&quot;Your portfolio value at the end of the day should be ${new_portfolio_value}&quot;) . Now, Your account value is $120.0 You have to buy $20.0 to keep the leverage(2) ratio. Your portfolio value at the end of the day should be $240.0 . Let&#39;s use synthetic data and find out what happen if we apply the Kelly criterion to investing. we assume there are 252 trading days in a year and risk free rate is zero. . # mean of annual return mu=0.05 # std of annual return sigma=0.216 def sample_daily_returns(mu, sigma, year, seed): np.random.seed(seed) return np.random.normal(mu/252, sigma/np.sqrt(252), 252*year) # 10 years of returns return_samples = sample_daily_returns(mu, sigma, seed=7777, year=10) #9999 . return_history = return_samples # convert row returns to log returns log_returns = np.log(1+return_history) # Calculating leverage and expected growth rate kelly_leverage, growth_rate = kelly_investing(log_returns, risk_free_rate=0., annualize_factor=252, raw_return=False) print(f&quot;kelly leverage: {kelly_leverage}&quot;) print(f&quot;growth rate: {growth_rate}&quot;) initial_capital = 100. account_value = initial_capital portfolio_value = kelly_leverage*account_value account_value_history = [initial_capital,] profit_history = [0,] portfolio_value_history = [portfolio_value,] # Simulates trade for r in return_history: account_value, portfolio_value, gap = kelly_trader(portfolio_value, account_value, kelly_leverage, r) account_value_history.append(account_value) profit_history.append(profit_history) portfolio_value_history.append(portfolio_value) . kelly leverage: 2.266550589450498 growth rate: 0.11748484759649569 . plt.figure(figsize=(10,5)) stock_price = 100*np.cumprod(1+return_history) plt.plot(stock_price, label=&quot;Price&quot;) plt.plot(account_value_history, color=&#39;r&#39;, label=&quot;Kelly $f^*$&quot;) plt.legend() plt.show() . The Kelly results look great, but the strategy following the Kelly Criterion has much bigger volatility than the other. You should be aware that we assume that the distribution of return follows gaussian and there is no constraint like training costs. . Fraction kelly . What happen if we do not follow the exact Kelly Criterion? For instance, If you bet more than twice of the Kelly leverage, the result will not be good because it makes your expected growth rate zero to use about twice the Kelly leverage, $2f^*$ [1]. . fractions = [0.5, 1.0, 1.5, 2.0] . return_history = return_samples # convert row returns to log returns log_returns = np.log(1+return_history) fraction_kelly_histories = [] for c in fractions: # Calculating leverage and expected growth rate kelly_leverage, growth_rate = kelly_investing(log_returns, risk_free_rate=0., annualize_factor=252, raw_return=False) # Fraction kelly kelly_leverage = c*kelly_leverage print(f&quot;{c} * kelly leverage = {kelly_leverage}&quot;) print(f&quot;growth rate: {growth_rate} n&quot;) initial_capital = 100. account_value = initial_capital portfolio_value = kelly_leverage*account_value account_value_history = [initial_capital,] profit_history = [0,] portfolio_value_history = [portfolio_value,] # Simulates trade for r in return_history: account_value, portfolio_value, gap = kelly_trader(portfolio_value, account_value, kelly_leverage, r) account_value_history.append(account_value) profit_history.append(profit_history) portfolio_value_history.append(portfolio_value) fraction_kelly_histories.append(account_value_history) . 0.5 * kelly leverage = 1.133275294725249 growth rate: 0.11748484759649569 1.0 * kelly leverage = 2.266550589450498 growth rate: 0.11748484759649569 1.5 * kelly leverage = 3.3998258841757467 growth rate: 0.11748484759649569 2.0 * kelly leverage = 4.533101178900996 growth rate: 0.11748484759649569 . # change type to pandas data frame type fraction_kelly_histories = np.array(fraction_kelly_histories).T fraction_kelly_hist_df = pd.DataFrame(fraction_kelly_histories) fraction_kelly_hist_df.columns = [ f&quot;{c:.1f}$f^*$&quot;for c in fractions] # add stock price (It is just buy and hold) stock_price = pd.Series(100*np.cumprod(1+return_history)) fraction_kelly_hist_df[&#39;price&#39;] = stock_price fraction_kelly_hist_df[&#39;price&#39;] = fraction_kelly_hist_df[&#39;price&#39;].shift(1) fraction_kelly_hist_df[&#39;price&#39;][0] = 100. . The kelly leverage outcome is the best. but, it has high volatility. You can see the worst result when we do bet more than twice of the Kelly leverage. . fraction_kelly_hist_df.tail() . 0.5$f^*$ 1.0$f^*$ 1.5$f^*$ 2.0$f^*$ price . 2516 296.487451 | 488.884687 | 446.999297 | 225.339581 | 268.970715 | . 2517 305.988597 | 520.217984 | 489.972504 | 254.224233 | 276.576416 | . 2518 313.978498 | 547.385598 | 528.354637 | 280.777202 | 282.949004 | . 2519 314.761197 | 550.114692 | 532.305955 | 283.576937 | 283.571402 | . 2520 312.765769 | 543.139791 | 522.182298 | 276.385997 | 281.985114 | . fraction_kelly_hist_df.plot(figsize=(20,10), title=&quot;Compare betwwen fractional kelly leverages&quot;) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fd0e76eee10&gt; . # Compare between Kelly leverage and &#39;buying and holding&#39; fraction_kelly_hist_df.iloc[:, [1, -1]].plot(figsize=(20,10), title=&quot;Compare between Kelly leverage and &#39;buying and holding&#39;&quot;) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fd0f332bc88&gt; . The main disadvantage of the Kelly criterion is that its suggested leverage may be very large. So, it can be very risk in the short term [6]. In addition, as seen in the above example of coin gambling, we are always exposed to the possibility of over betting which might lead to the negative growth rate of the wealth. Therefore, it is reasonable for investors who want to have higher safety use fractional Kelly rather than exact Kelly leverage [6]. Many practitioners suggest using half of the Kelly leverage. We can view Kelly&#39;s optimal leverage as the upper bound of the leverage [2]. . kelly allocation . we can use the Kelly criterion not only to the single asset or strategy but also to the multiple assets or strategies. In this case, we should consider correlation between them. . Based on the paper by Thorp [1], the optimal allocation and the expected growth return are below. . $$ F^{*} = C^{-1}[M-R] $$ . $$ g(F^{*}) = r + frac{(F^{*})^{T}CF^{*}}{2} $$ . $$ M: (m_{1}, m_{2}, ..., m_{n})^{T}, m_{i} text{is the drift rate of the } ith text{ security} $$ . $$ C: text{covariance matrix}, C_{ij} text{is the covariance of the } ith text{ and } jth text{ securities} $$ . $$ F^{T}: (f_{1}, f_{2}, ...,f_{n}) $$ . $$ R: (f_{1}, f_{2}, ...,f_{n})^{T} $$ . $$ f_{0} : text{riskless security with portfolio fractions} $$ . $$ f_{1}, ..., f_{n} : text{n securities with portfolio fractions}$$ . Let&#39;s check this with real data.($ text{risk free rate}$ is 0.02) . stock_prices = pd.read_csv(&quot;mlfinlab/tests/test_data/stock_prices.csv&quot;, index_col=0) assets_df = stock_prices[[&quot;SPY&quot;, &quot;EEM&quot;, &quot;TLT&quot;]] assets_log_return_df = np.log(assets_df/assets_df.shift(1)).dropna() . kelly_allocations, growth_rate = kelly_allocation(assets_log_return_df, risk_free_rate=0.02, annualize_factor=252, raw_return=False ) for ticker, kelly in zip([&quot;SPY&quot;, &quot;EEM&quot;, &quot;TLT&quot;], kelly_allocations): print(f&quot;{ticker}: {kelly:.2f}&quot;) print(f&quot;Total leverage: {np.sum(abs(kelly_allocations)):.2f}&quot;) print(f&quot; n Annualized compounded growth rate: {growth_rate:.2f}&quot;) . SPY: 6.17 EEM: -3.69 TLT: 1.76 Total leverage: 11.62 Annualized compounded growth rate: 0.23 . Conclusion . Here, we explore the applications of Kelly criterion which asymptotically maximizes the expected compound growth rate of the wealth [1]. It can be a great framework of money management that seeks to find a sweet spot between absolute return and risk in the long-term. But in the real world, we are more likely to make a bet bigger than the Kelly Criterion and experience high volatility. Therefore, it is encouraged to use less wisely than to follow the Kelly Criterion correctly. . Reference . [1] A New Inerpretation of Information Rate(1956) By John Larry Kelly. | [2] Algorithmic Trading : Winning Strategies and Their Rationale By Ernest P. Chan, John Wiley &amp; Sons, 2013. | [3] Successful Algorithmic Trading: Applying the scientific method for profitable trading results By Michael L. Halls-Moore. | [4] Loss aversion is not a behavioral bias by Ernest P. Chan | [5] How you will go bust on a favorable bet by Nassim Nicholas Taleb | [6] Good and bad properties of the Kelly criterion by Leonard C. MacLean, Edward O. Thorp and William T. Ziemba. | .",
            "url": "https://jihobak.github.io/marketneutral/2020/09/10/Kelly-Criterion.html",
            "relUrl": "/2020/09/10/Kelly-Criterion.html",
            "date": " • Sep 10, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://jihobak.github.io/marketneutral/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://jihobak.github.io/marketneutral/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://jihobak.github.io/marketneutral/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}